## Основы

*Алгоритм* - это последовательность действий, которые решают какую-нибудь задачу. Любой код можно назвать алгоритмом.

*Структура данных* — способ организации и хранения данных, устроенный максимально эффективным способом.

*Big O* — нотация, которая позволяет определить верхнюю границу *скорости* и *памяти* работы алгоритма.
Это асимптотическая сложность, которая описывает верхнюю границу сложности алгоритма при увеличении
размера входных данных, или то, как рост размера входных данных влияет на количество операций.

    Обычный обход по массиву имеет сложность O(n), где n — количество элементов массива.
    Если внутри этого цикла добавить ещё один, который также будет проходить по всем
    элементам массива, то сложность внешнего цикла возрастёт до O(n2).

    В Big O константы откидываются, представим ситуацию, что у нас существует функция,
    в которой существуют 2 одинаковых цикла. Сложность её будет не O(2n), как может
    вполне логично показаться, а O(n). Нотация Big O обращает внимание конкретно на
    число входных элементов — n, также на степени, логарифмы, факториалы и экспоненты
    этого числа. 

*Принцип LIFO* (Last In First Out) Последним зашёл, первым вышел

*Принцип FIFO* (First In First Out) Первым зашёл, первым вышел



## Структуры

*Граф*. Структура данных, состоящая из «вершин» и «ребёр». Вершины имеют значение, именуемое «вес»,
рёбра соединяют вершины друг с другом. Получается своего рода сущность в виде сетки. 

*Дерево*. При тщательном рассмотрении может показаться, что дерево очень похоже на граф, и так оно
и есть. Это структура данных, представляющая собой связанный граф, не имеющий циклов. 

*Бинарное дерево*. Дерево, в котором каждый узел имеет не более двух дочерних узлов.

*Стек*. Базовая структура данных, в которой реализовано только добавление и удаление элементов.
Данные в этой структуре организованы по принципу LIFO

*Очередь*. Структура данных, название которой говорит само за себя. В ней также реализованы лишь
методы добавления и удаления элементов. В этой структуре данные организованы по принципу FIFO

*Связный список (linked list)* Динамическая структура данных, представляющая собой упорядоченную
коллекцию узлов (nodes). Каждый узел содержит значение и ссылку (указатель) на следующий узел

*Двусвязный список (doubly linked list)* Похож на односвязный, но узлы такого списка, помимо
ссылок на следующие узлы, содержат также ссылки на предыдущие узлы.

*Таблица хеширования (hash table)* Структура данных, представляющая собой набор пар ключ-значение
*Коллизия* — случай, когда два элемента имеют одинаковое значение



## Алгоритмы сортировки

*Стабильная сортировка* Сортировка, которая не меняет порядок равных элементов


### Сортировка пузырьком (bubble sort)
Сложность алгоритма | O(n2)
Когда применять     | При малом количестве элементов
Флаги               | Стабильный
Описание

Сортировка пузырьком перебирает весь массив элементов, сравнивая два соседних элемента друг с другом
и меняя их местами в соответствии с условиями. Элементы с большим значением опускаются вниз массива,
а элементы с наименьшим значением поднимаются вверх


### Сортировка выбором (selection sort)
Сложность алгоритма | O(n2)
Когда применять     | При малом количестве элементов
Флаги               | Стабильный
Описание

Алгоритм сортировки при каждой итерации проходит по не отсортированной части массива,
находит минимальный элемент и помещает его в начало отсортированной части массива


### Быстрая сортировка (quick sort)
Сложность алгоритма | O(n * log(n))
Когда применять     | При большом количестве элементов
Флаги               | Нестабильный
Описание

Он определяет так называемый «стержень» и разбивает массив на подмассивы
относительно «стержня», которые затем сортируются.


### Циклическая сортировка (cycle sort)
Сложность алгоритма | O(n2)
Когда применять     | При малом количестве элементов. Если изменение значение массива затратное
Флаги               | Нестабильный
Описание

Основной идеей алгоритма циклической сортировки является разложение массива на циклы.
Затем, внутри этих циклов происходят перестановки элементов до тех пор, пока все циклы
не завершатся и массив не будет отсортирован.


## Алгоритмы поиска

### Линейный поиск (linear search)
Сложность алгоритма | O(n)
Когда применять     | При малом количестве элементов
Описание

Идём по каждому элементу, возвращаем индекс первого совпадения
 

### Бинарный поиск (binary search)
Сложность алгоритма | O(log n)
Когда применять     | При сортированном массиве
Описание

Находим средний элемент массива, если он равен искомому, то возвращаем его индекс.
Если больше, то отрезаем правую часть, а если меньше, то левую.


### Поиск в глубину (depth-first search)
Сложность алгоритма | O(V + E)
Когда применять     | Когда мы знаем, что искомая вершина находится дальше всего от стартовой, или если граф имеет большую ширину
Описание

Алгоритм обхода или поиска в таких структурах данных, как деревья или графы.
Основан на такой структуре данных, как стек. Алгоритм начинает работу с корневого
узла (в случае графа в качестве корневого узла выбирается какой-либо произвольный
узел) и прежде чем вернуться назад, проходит как можно дальше по каждой ветви.

### Поиск в ширину (breadth-first search)
Сложность алгоритма | O(V + E)
Когда применять     | Когда мы знаем, что искомая вершина находится близко к стартовой, или если граф имеет большую глубину
Описание

Алгоритм поиска в ширину очень похож на описанный выше алгоритм поиска в глубину,
отличается лишь тем, что в начале проходит все соседние узлы начальной вершины,
потом все соседние узлы соседних вершин, и так далее, пока не пройдёт весь граф
или не найдёт искомую вершину. Ещё одно отличие заключается в том, что основан
этот алгоритм на такой структуре данных, как очередь.

### Алгоритм Дейкстры (Dijkstra)
Сложность алгоритма | O(E * log V)
Когда применять     | Когда необходимо найти кратчайший путь в взвешенном графе
Описание

Основная идея алгоритма — создание дерева кратчайших путей с заданным источником
в качестве корня. Алгоритм Дейкстры — один из самых популярных алгоритмов для
нахождения короткого пути в взвешенном графе. Незаменим в работе GPS-навигации.


## Прочие алогритмы

### Два указателя (two pointers)
TODO


### Скользящее окно (sliding window)
Сложность алгоритма | O(n)
Когда применять     | Когда необходимо найти кратчайший путь в взвешенном графе
Описание

Метод скользящего окна — это техника, используемая для решения задач на массивах
или строках, при которой фиксированный подмассив (или подстрока) перемещается
по данным с целью поиска оптимального решения.
