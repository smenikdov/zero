/*
Лексическое окружение (Lexical Environment) — это термин, который используется для определения
связи между идентификаторами и отдельными переменными и функциями на основе структуры лексической
вложенности ECMAScript-кода. Лексическое окружение состоит из записи окружения (Environment Record)
и ссылки на внешнее лексическое окружение, которая может принимать значение null.

Стек выполнения (execution stack), который ещё называют стеком вызовов (call stack), это LIFO-стек,
который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.

Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и
помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст
выполнения для этой функции и помещает его в верхнюю часть стека. Когда работа функции завершается,
её контекст извлекается из стека.

1) Значение this определяется в момент исполнения кода, а создаются в момент вызова функции
2) Стрелочные функции не имеют контекста

*/

// Object =========================================================================================
const stoic = {
    name: 'Stoic',
    sayHi() {
        console.log(this.name);
    },
};
stoic.sayHi();    // Stoic
stoic['sayHi'](); // Stoic

const sayHi = stoic.sayHi;
sayHi();          // undefined

const mark = {
    name: 'Mark',
};
mark.sayHi = stoic.sayHi;
mark.sayHi();      // Mark


// Function =======================================================================================
function sayHiFunction() {
    console.log(this.name);
};
sayHiFunction(); // error | undefined

mark.sayHi = sayHiFunction;
mark.sayHi();    // Mark

// Arrow Function =================================================================================
const ilya = {
    name: 'Ilya',
    sayHi() {
        const arrow = () => console.log(this.name);
        arrow();
    }
};

ilya.sayHi(); // Ilya

// Example ========================================================================================
function makeUser() {
    return {
        name: 'John',
        ref: this
    };
}
const john = makeUser(); // this определяется в момент вызова
console.log( user.ref ); // undefined | global object

// Example ========================================================================================
function makeUser2() {
    return {
        name: 'Oleg',
        ref() {
            return this;
        }
    };
}
const oleg = makeUser2();
console.log(oleg.ref().name); // Oleg, this определяется в момент вызова
