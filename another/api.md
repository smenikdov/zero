# Конспект по API микросервисов

## Определения

### Микросервис
Микросервис — это небольшой, автономный программный компонент, который выполняет одну конкретную функцию в рамках большой системы. Микросервисы разрабатываются, развертываются и масштабируются независимо, взаимодействуя через четко определенные интерфейсы, такие как API.

### API
API (Application Programming Interface, интерфейс программирования приложений) — это набор правил и инструментов, позволяющих различным программным компонентам взаимодействовать друг с другом. API определяет, как запросы и данные должны быть структурированы, не раскрывая внутренней реализации.

### Веб-API
Веб-API — это разновидность API, которая использует протоколы и технологии веба (например, HTTP/HTTPS) для взаимодействия между клиентом и сервером. Обычно веб-API предоставляют доступ к данным или функциям через REST, GraphQL или другие архитектурные стили.

### REST API
REST API (Representational State Transfer) — это веб-API, следующее архитектурному стилю REST, основанному на принципах stateless-взаимодействия, использования HTTP-методов (GET, POST, PUT, DELETE) и представлении данных в формате ресурсов (например, JSON).

### RESTful API
RESTful API — это API, которое полностью соответствует принципам REST, включая клиент-серверную архитектуру, отсутствие состояния, кэшируемость, многоуровневость и единообразие интерфейса.

### Альтернативы REST
- **GraphQL**: API, позволяющее клиентам запрашивать только необходимые данные с помощью единой точки входа.
- **gRPC**: Высокопроизводительный RPC-фреймворк, использующий HTTP/2 и Protocol Buffers для обмена данными.
- **SOAP**: Протокол обмена структурированными данными, основанный на XML, часто используемый в корпоративных системах.
- **WebSocket**: Протокол для двунаправленного обмена данными в реальном времени.

## HTTP-методы и их использование

1. **GET**
   - Используется для получения данных от сервера. Метод безопасный и идемпотентный, не изменяет состояние ресурса. Пример: получение списка пользователей.

2. **POST**
   - Используется для создания новых ресурсов на сервере. Передает данные в теле запроса. Не идемпотентный. Пример: создание нового пользователя.

3. **PUT**
   - Используется для обновления существующего ресурса или создания ресурса, если он не существует. Идемпотентный. Пример: обновление данных пользователя.

4. **DELETE**
   - Используется для удаления ресурса на сервере. Идемпотентный. Пример: удаление пользователя по ID.

5. **PATCH**
   - Используется для частичного обновления ресурса, изменяя только указанные поля. Не обязательно идемпотентный. Пример: изменение email-адреса пользователя.

6. **HEAD**
   - Аналогичен GET, но возвращает только заголовки ответа без тела. Используется для проверки метаданных ресурса. Пример: проверка существования ресурса.

7. **OPTIONS**
   - Используется для получения информации о доступных методах и возможностях сервера для конкретного ресурса. Пример: проверка, какие HTTP-методы поддерживает API.

## Способы формирования тела запроса

1. **JSON (JavaScript Object Notation)**
   - Легковесный формат для структурированных данных, широко используемый в REST API. Компактный, легко читаемый, поддерживается большинством языков программирования. Пример: `{"name": "John", "age": 30}`.

2. **XML (Extensible Markup Language)**
   - Формат для структурированных данных, часто используемый в SOAP и корпоративных системах. Более громоздкий, чем JSON, но поддерживает сложные схемы. Пример: `<user><name>John</name><age>30</age></user>`.

3. **Form-data (multipart/form-data)**
   - Формат для отправки пар "ключ-значение" и файлов через HTTP. Используется в формах веб-приложений и API для загрузки файлов. Пример: отправка изображения с метаданными.

4. **URL-encoded (application/x-www-form-urlencoded)**
   - Формат для передачи пар "ключ-значение" в теле запроса или строке URL. Простой, но ограничен для сложных данных. Пример: `name=John&age=30`.

5. **Plain Text (text/plain)**
   - Простой текстовый формат для передачи неструктурированных данных. Используется редко, в специфичных случаях. Пример: отправка строки логов.

6. **Protocol Buffers**
   - Бинарный формат, используемый в gRPC. Компактный и быстрый, но требует определения схемы. Подходит для высокопроизводительных систем.

## Группы HTTP-статус кодов

1. **1xx (Информационные)**
   - Указывают, что запрос получен и обработка продолжается. Используются редко, обычно для промежуточных ответов. Пример: 100 Continue.

2. **2xx (Успех)**
   - Запрос успешно принят, понят и обработан сервером. Указывают на успешное выполнение действия. Пример: 200 OK, 201 Created.

3. **3xx (Перенаправление)**
   - Указывают, что клиенту нужно предпринять дополнительные действия, например, перейти по другому URL. Пример: 301 Moved Permanently, 302 Found.

4. **4xx (Ошибки клиента)**
   - Ошибка в запросе со стороны клиента, например, неверные данные или отсутствие прав. Пример: 400 Bad Request, 404 Not Found.

5. **5xx (Ошибки сервера)**
   - Сервер не смог обработать запрос из-за внутренней ошибки или недоступности. Пример: 500 Internal Server Error, 503 Service Unavailable.

## HTTP-статус коды

1. **200 OK**
   - Запрос успешно выполнен, данные возвращены. Пример: успешное получение списка пользователей.

2. **201 Created**
   - Ресурс успешно создан в результате запроса. Пример: создание нового пользователя.

3. **204 No Content**
   - Запрос выполнен успешно, но тело ответа отсутствует. Пример: успешное удаление ресурса.

4. **400 Bad Request**
   - Сервер не может обработать запрос из-за ошибки клиента, например, неверного формата данных. Пример: отправка некорректного JSON.

5. **401 Unauthorized**
   - Требуется аутентификация, пользователь не авторизован. Пример: доступ без токена.

6. **403 Forbidden**
   - Пользователь аутентифицирован, но не имеет прав для выполнения запроса. Пример: попытка доступа к чужим данным.

7. **404 Not Found**
   - Запрашиваемый ресурс не найден на сервере. Пример: обращение к несуществующему пользователю.

8. **405 Method Not Allowed**
   - Использован неподдерживаемый HTTP-метод для ресурса. Пример: попытка использовать POST вместо GET для получения данных.

9. **422 Unprocessable Entity**
   - Запрос синтаксически корректен, но сервер не может его обработать из-за семантических ошибок. Пример: отправка данных, не соответствующих валидации.

10. **500 Internal Server Error**
    - На сервере произошла непредвиденная ошибка. Пример: сбой в обработке запроса из-за ошибки кода.

11. **501 Not Implemented**
    - Сервер не поддерживает функциональность, необходимую для обработки запроса. Пример: запрос неподдерживаемого метода или API.

12. **503 Service Unavailable**
    - Сервер временно недоступен, например, из-за перегрузки или технического обслуживания. Пример: сервис на профилактике.

13. **504 Gateway Timeout**
    - Сервер, выступающий как шлюз или прокси, не получил своевременный ответ от вышестоящего сервера. Пример: тайм-аут при обращении к внешнему API.

## Документирование API

### OpenAPI
OpenAPI (ранее Swagger) — это стандарт для описания и документирования HTTP API. Он позволяет формально описать структуру API, включая конечные точки, методы, параметры, форматы данных и статус-коды, в машиночитаемом формате (JSON или YAML). Используется для генерации документации, клиентских библиотек и тестирования.

### JSON Schema
JSON Schema — это спецификация для описания структуры и валидации JSON-данных. Она определяет типы данных, обязательные поля, форматы и ограничения. Используется в API для документирования ожидаемых запросов и ответов, а также для автоматической валидации данных.

### Пример использования OpenAPI с JSON Schema
Ниже приведен пример описания API для конечной точки `/users` с использованием OpenAPI, включающего JSON Schema для структуры данных пользователя.

```json
{
    "openapi": "3.0.3",
    "info": {
        "title": "User API",
        "version": "1.0.0"
    },
    "paths": {
        "/users": {
            "post": {
                "summary": "Create a new user",
                "requestBody": {
                    "required": true,
                    "content": {
                        "application/json": {
                            "schema": {
                                "$ref": "#/components/schemas/User"
                            }
                        }
                    }
                },
                "responses": {
                    "201": {
                        "description": "User created successfully",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "$ref": "#/components/schemas/User"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input"
                    }
                }
            }
        }
    },
    "components": {
        "schemas": {
            "User": {
                "type": "object",
                "required": ["name", "email"],
                "properties": {
                    "name": {
                        "type": "string",
                        "example": "John Doe"
                    },
                    "email": {
                        "type": "string",
                        "format": "email",
                        "example": "john.doe@example.com"
                    },
                    "age": {
                        "type": "integer",
                        "minimum": 18,
                        "example": 30
                    }
                }
            }
        }
    }
}
```

## Аутентификация и авторизация

### Аутентификация
Аутентификация проверяет, кто делает запрос.

### Авторизация
Авторизация определяет, какие действия разрешены пользователю.

### JWT
JWT (JSON Web Token) — компактный, самодостаточный токен для передачи данных между сторонами в формате JSON. Используется для аутентификации и авторизации, содержит закодированные данные (утверждения), подписанные для проверки целостности.

### Способы реализации авторизации в REST API

1. **Basic Authentication**
   - Простой метод, использующий логин и пароль, закодированные в Base64, в заголовке `Authorization`. Небезопасен без HTTPS, подходит для простых сценариев.

2. **OAuth 2.0**
   - Протокол авторизации, позволяющий предоставлять доступ к ресурсам от имени пользователя через токены доступа. Поддерживает различные потоки (flows) для приложений, веб-сайтов и устройств.

3. **OAuth 2.0 + PKCE (Proof Key for Code Exchange)**
   - Расширение OAuth 2.0 для повышения безопасности в мобильных и одностраничных приложениях. Использует динамически генерируемый ключ для защиты от перехвата кода авторизации.

4. **API Key**
   - Уникальный ключ, передаваемый в запросах (обычно в заголовке или параметре). Прост в реализации, но менее безопасен, так как ключ может быть скомпрометирован.

5. **OpenID Connect**
   - Надстройка над OAuth 2.0, добавляющая слой аутентификации. Предоставляет токены ID для подтверждения личности пользователя, часто используется в SSO (Single Sign-On).

## JSON Web Token (JWT)

### Структура JWT
JWT состоит из трех частей, разделенных точками (`.`): **Header**, **Payload**, **Signature**. Каждая часть кодируется в Base64.
- **Header**: Содержит метаданные о токене, включая тип (`JWT`) и алгоритм подписи (например, `HS256`).
- **Payload**: Содержит утверждения (claims) — данные о пользователе или сессии.
- **Signature**: Подпись, созданная с использованием секрета или ключа для проверки целостности токена.

Пример JWT:  
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

### Алгоритмы шифрования
- **HS256 (HMAC + SHA-256)**: Симметричный алгоритм, использующий один секретный ключ для подписи и проверки.
- **RS256 (RSA + SHA-256)**: Асимметричный алгоритм, использующий пару ключей (публичный и приватный).
- **ES256 (ECDSA + SHA-256)**: Использует эллиптические кривые для подписи, обеспечивая высокую безопасность при меньшем размере ключа.
- **None**: Отсутствие подписи (небезопасно, не рекомендуется).

### Где применяется
- Аутентификация в REST API: передача токена в заголовке `Authorization: Bearer <token>`.
- Авторизация: проверка прав доступа на основе утверждений в Payload.
- SSO: обмен информацией о пользователе между системами.
- Микросервисные архитектуры: передача данных между сервисами без сохранения состояния.

### Зарезервированные утверждения JWT
- **iss (issuer)**: Издатель токена, идентифицирует систему, выпустившую токен.
- **sub (subject)**: Субъект токена, обычно ID пользователя или клиента.
- **aud (audience)**: Получатель токена, указывает, для кого предназначен токен.
- **exp (expiration)**: Время истечения срока действия токена (в формате Unix timestamp).
- **nbf (not before)**: Время, начиная с которого токен действителен.
- **iat (issued at)**: Время выпуска токена.
- **jti (JWT ID)**: Уникальный идентификатор токена для предотвращения повторного использования.

## Проблемы микросервисной архитектуры

1. **Оптимальная декомпозиция**
   - Разделение монолитного приложения на микросервисы требует определения границ сервисов. Неправильная декомпозиция может привести к избыточной связанности, дублированию функциональности или слишком мелким сервисам, усложняющим управление.

2. **Обработка недоступности сервиса**
   - В распределенной системе микросервисы могут временно становиться недоступными из-за сбоев сети, перегрузки или отказов. Это требует механизмов устойчивости, таких как повторные попытки, тайм-ауты или "отбойники" (circuit breakers).

3. **Трассировка недоступных транзакций**
   - В микросервисной архитектуре транзакции проходят через множество сервисов, что затрудняет отслеживание ошибок или узких мест. Отсутствие централизованной трассировки усложняет диагностику.

4. **Интеграционные тесты**
   - Тестирование взаимодействий между микросервисами сложнее, чем тестирование монолита, из-за их распределенной природы и зависимости от внешних систем. Поддержание тестовых сред и данных требует значительных усилий.

## Принципы проектирования микросервисов

1. **База данных для каждого сервиса**
   - Каждый микросервис должен иметь собственную базу данных, и один микросервис не должен напрямую получать или управлять данными другого. Это обеспечивает независимость и изоляцию данных.

2. **Слабая связанность**
   - Микросервисы должны быть минимально зависимы друг от друга, взаимодействуя только через четко определенные API. Это позволяет изменять или заменять сервис без влияния на другие.

3. **Единственная ответственность**
   - Каждый микросервис должен отвечать за одну конкретную бизнес-функцию или задачу, следуя принципу единственной ответственности (Single Responsibility Principle).

4. **Автономность**
   - Микросервисы должны быть полностью автономными, включая возможность независимого развертывания, масштабирования и обновления без координации с другими сервисами.

## Безопасность
- HTTPS и шифрование. Использование HTTPS (TLS/SSL) защищает передаваемые данные от перехвата и атак типа «человек посередине» (MITM). Любой API, работающий с чувствительными данными, должен использовать HTTPS по умолчанию.
- Ограничение запросов (Rate Limiting). Защищает API от перегрузок и атак, таких как DDoS. Пример политики:
   * не более 100 запросов в минуту с одного IP;
   * возврат 429 Too Many Requests при превышении лимита.
   * Валидирование данных и защита от атак
- Проверка входных данных предотвращает SQL-инъекции и XSS-атаки.
- Использование Content-Type и CORS защищает API от несанкционированных межсайтовых запросов.
- Логирование и мониторинг. Запись всех запросов, ошибок и подозрительной активности помогает выявлять атаки и анализировать работу API.
- Ограничение доступа к данным. Не все данные должны быть доступны всем пользователям. Для этого используются ролевые модели доступа (RBAC) и политики защиты конфиденциальности.

## Тестирование
- Функциональное тестирование. Оценивается, корректно ли API обрабатывает запросы и возвращает ожидаемые ответы. Проверяются:
   * корректность HTTP-методов (GET, POST, PUT, DELETE);
   * структура и содержание ответов (JSON, XML);
   * соответствие кодов состояния (200 OK, 400 Bad Request и т. д.).

- Нагрузочное тестирование. Оценивается, как API ведёт себя при высокой нагрузке. Проверяется:
   * способность API обрабатывать большое количество запросов одновременно;
   * устойчивость к перегрузкам;
   * поведение при Rate Limiting (при ограничении частоты запросов).

- Тестирование на безопасность. Проверяется защита API от атак:
   * SQL-инъекции (передача вредоносных SQL-запросов);
   * XSS-атаки (внедрение вредоносного кода);
   * атаки перебором (Brute Force) на аутентификацию.

- Интеграционное тестирование. Оценивается взаимодействие API с другими сервисами, базами данных, платёжными шлюзами и внешними системами.

- Автоматизация тестирования. Тестирование REST API можно автоматизировать с помощью инструментов:
   * Postman — ручное и автоматизированное тестирование API;
   * JUnit (Java), pytest (Python) — тестирование API в коде;
   * Swagger (OpenAPI) — проверка соответствия спецификации.
